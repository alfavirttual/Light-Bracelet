//#include <avr/iotn13a.h>
#include <avr/io.h>
#include <avr/interrupt.h>


unsigned char c = 0;
unsigned char h = 0;

unsigned char &config = c; 
unsigned char &hold_tap = h;

ISR(INT0_vect){
  
  if (config & 0b00010000){ // Если разблокированно 
  
    if(PINB & (1 << PB1)){ // Кнопка нажата
      TCNT0 = 254; // Настройка таймера на срабатывание через 0.02 секунды
      TCCR0B |= (1 << CS02) | (1 << CS00); //Запуск таймера с делителм на N = 1024
      if (config > 128) { // Если учтановлен режим
          TCCR0B &= ~(1 << CS02) & ~(1 << CS00);
          PORTB &= ~(1 << PB3) & ~(1 << PB2) & ~(1 << PB4) & ~(1 << PB5);
          hold_tap = 0;
          config = 0;
    }}
    else { // Если кнопка отжата 
        
      if (config < 128){
        if ((config & 0b01110000) != 80) config += 32;
        else config = 0b00010000;
        hold_tap = 0;
      }
    }
 
  } 
  else {  // Если заблокированно
  
  if (PINB & (1 << PB1)){ // кнопка нажата 

    TCNT0 = 156; // Настройка таймера на срабатывание через 0.8 секунды
    TCCR0B |= (1 << CS02) | (1 << CS00); //Запуск таймера с делителм на N = 1024
    
  config ++;
  }
  else {//кнопка отжата
    
    TCCR0B &= ~(1 << CS02) & ~(1 << CS00); // Останавливаем таймер
    PORTB &= ~(1 << PB3); // Если таймер не успел досчитать, а светодиод горел 

    switch (config & 0b00001111) 
    {
    case 0b00001111: // Если произошла разблокировка
      config = 0b00010111;
      TCNT0 = 254; // Настройка таймера на срабатывание через 0.02 секунды
      TCCR0B |= (1 << CS02) | (1 << CS00); //Запуск таймера с делителм на N = 1024
      break;
    case 0b00000111: // Обнуляем счётчик нажатий при переполнении 
      config = 0;
      break;
    default:
      if(TCNT0 > 200) {// Смотрим входит ли в период короткого нажатия
        config = 0b00000001;
      }
      if (config != 0) config ++;
      break;
    }
  } 
}
}


ISR(TIM0_OVF_vect){
    
    if (config & 0b00010000){ // Если разблокированно 
      if((config < 128)){ // Если режим не выбран
        TCNT0 = 225; // переход по вектору прерывания через 0.25 секунды
        OCR0A = 249; // переход по вектору прерывания через 0.2 секунды
        if (PINB & (1 << PB1)) hold_tap ++;
        TCCR0B |= (1 << CS02) | (1 << CS00); //Запуск таймера с делителм на N = 1024
      }
      
      switch((config & 0b01110000)){
        case 16: // Если выбран режим 0 
          if (hold_tap < 4) PORTB |= (1 << PB4); // Удерживается менее 0.75 секунд
            else {
              TCCR0B &= ~(1 << CS02) & ~(1 << CS00);
              hold_tap = 0;
              config = 0b10010000;
              PORTB |= (1 << PB5);
            }
        break;

        case 48: 
        if (hold_tap < 4) PORTB |= (1 << PB2);
          else {
            PORTB |= (1 << PB5);
            TCNT0 = 231; // Переход по вектору прерывания через 0.2 секунды
            OCR0A = 243; // Переъод по вектору прерывния через 0.1 секунды (период стробоскопа)
            config = 0b10110000;
            }    
          TCCR0B |= (1 << CS02) | (1 << CS00); //Запуск таймера с делителм на N = 1024  
          break;

        case 80:
          if (hold_tap < 4) PORTB |= (1 << PB3);
            else {
              config = 0b11010000;
              PORTB |= (1 << PB5);
              if (hold_tap <= 6){
                hold_tap ++;
                TCNT0 = 206; // Срабатывание через 0.4 секунды 
                OCR0A = 231; // Срабатывание через 0.2 секунды
              }
              else if(hold_tap <= 9){
                hold_tap ++;
                TCNT0 = 156; // Срабатывание через 0.8 секунды
                OCR0A = 206; // Срабатывание через 0.4 секунды 
              }
              else if(hold_tap == 10) {
                hold_tap = 4;
                TCNT0 = 254;
              }
            }
          TCCR0B |= (1 << CS02) | (1 << CS00); //Запуск таймера с делителм на N = 1024
          break;
        }
    }
  else { // Если заблокированно
  
  PORTB |= (1 << PB3);
  TCNT0 = 156; // Настройка таймера на срабатывание через 0.8 секунды
  OCR0A = 168; // Настройка прерывания для моргания на 100 миллисекунд TCNT0 + 12

  if ((config & 0b00000111) != 5) config = 0;
  else config = 0b00001111; 
  TCCR0B |= (1 << CS02) | (1 << CS00); //Запуск таймера с делителм на N = 1024
  }
}

ISR(TIM0_COMPA_vect){
  PORTB &= ~(1 << PB3) & ~(1 << PB2) & ~(1 << PB4);
  if (config > 175) PORTB &= ~(1 << PB5); // Выключение светодиода для второго и третьего режима
} 
 

void interrrupt_ini(){
  DDRB &= ~(1 << PB1); // Настраиваю пин на вход
  GIMSK |= (1 << INT0); // Разрешаю прерывания по INT0
  MCUCR |= (1 << ISC00); // Прерывание при смене логического уровня
  GIFR = (1 << INTF0); // Очищаем регистр флагов прерываний 
}

void timer_ini(){
// TCCR0A |= (0 << WGM01) | (0 << WGM00); // Режим сравнения с регистром OCR0A
  TIMSK0 |= (1 << OCIE0A) | (1 << TOIE0); // Включил прерывания по совпадению с OCR0A и OCR0B и по переполнению счётчика
}


int main(){

  interrrupt_ini();
  timer_ini();
  
  DDRB |= (1 << PB4) | (1 << PB3) | (1 << PB2) | (1 << PB5);
//  PORTB &= ~(1 << PB4) & ~(1 << PB3) & ~(1 << PB2) & ~(1 << PB5);

  SREG |= (1 << 7); // Разрешаю глобальные прерывания

  while(1){

  }

  return 0;

}